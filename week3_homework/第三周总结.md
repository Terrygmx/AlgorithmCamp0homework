# 树与图

## 树
和链表相比，树具有多个后继节点（子节点）

### 二叉树
每个父亲节点有两个子节点的树  
如果叶子节点布满了一层（叶子节点个数为2^n），则为满二叉树  
如果叶子节点全位于左边的父亲节点，则为完全二叉树

### 定义树的节点
对于二叉树，定义一个树节点的值，以及其左右子节点即可  
类似地，N叉树就需要为每个父节点定义N个子节点

### 二叉树的遍历
分为前序，中序，后序，层次序等  
其中前序又称为深度优先遍历，一般使用递归求解  
层次序又称为广度优先遍历，一般需要引入队列求解

## 实战
### 遍历二叉树
前、后、中序遍历二叉树或多叉树，都可以用递归求解

### 序列化和反序列化
树的序列化和反序列化，注意可以使用前序、中序，或者中序、后序来构造二叉树。  
前序和后序则不能唯一确定一颗二叉树。

### 最近公共祖先
可以先找出各节点的父节点，然后用向上标记法，对于第二个节点，第一次遇到已经被第一个节点标记的祖先节点，则为最近公共祖先

### 基环树
在一棵树添加一条边就是一个环

## 图
图就是多个节点，加上节点之间的关系（边）组成的数据结构。树可以看作特殊化的图

### 图的存储
有邻接矩阵、出边数组、邻接表等方法。推荐使用出边数组。邻接矩阵的空间是N平方，而邻接表类似哈希表，每个点的邻接关系使用链表存储，访问效率低。  

### 图的遍历
类似树，也有深度优先、广度优先。  
深度优先可以用来在无向图中找环、划分连通块  
广度优先可以用来在有向图中找环，进行拓扑排序等  

### 图的DFS
要注意，因为图存在环，必须使用visit矩阵，标识结点是否已经访问过，防止重复处理同一节点  

# 深度优先搜索、广度优先搜索
**搜索是解决一切问题的万金油算法，学会定义搜索框架，可以帮助血虚图论、动态规划等**
**搜索题是训练代码能力最有效的题目类别**

## 状态
什么是状态？  
题面中涉及到的所有数学信息，我们关注的数据。一个函数访问的所有变量

我们只关注**动态变化的**数据

一个状态，对应了一种动态数据构成的集合。而状态空间就是所有可能状态的集合。  

把状态看作点，一个状态如果可以到达另一个状态，就可以连上一条边。这样状态空间可以抽象为一张有向图。而对问题的求解，就是对这张图的遍历。


## 搜索

采用直接遍历整个状态空间的方式寻找答案的算法  
状态空间是“图”而不是“树”时，需要判重（记忆化）

### 解题步骤
1. 纸上模拟，提取信息
2. 定义状态
3. 确定遍历顺序
4. 定义搜索框架
	- DFS，状态作为参数，确定递归边界，注意还原现场
	- BFS，状态使用队列保存
	- 考虑是否需要判重
5. 程序实现

### DFS vs BFS

DFS更适合搜索树形状态空间  
BFS适合求“最小代价”、”最少步数“等题目  

状态空间为一般的”图“（需要判重），则二者差不多  