## 哈希表

通过Hash函数，把信息映射到一个较小区域内

由两部分组成： 

1.  一个数据结构，通常是数组
2.  Hash函数，有很多函数，简单的例如对key求Hash再取模，作为数组的索引

### 哈希冲突：

1.  把大量信息映射到小的值域，发生冲突（碰撞）是不可避免的
2.  可以使用链表来解决冲突问题，但是如果冲突很多，哈希表会退化成链表，访问时间复杂度变成O(N)
3.  好的Hash函数可以减少冲突发生的概率，让数据尽可能均衡分布
4.  如果信息大于值域大小一定倍数，一般会重新设计哈希函数、值域大小，重新进行分布


### 时间复杂度：

-   最好（数据分布均衡）：插入、查询、删除：O(1)
-   最坏（退化称为链表）：插入、查询、删除：O(n)

### 应用：

-   快速查找
-   去重
-   分组
-   统计频率



## 集合

存储不重复元素

-   有序集合：一般用平衡二叉树实现，可以按照升序或降序排列（增删查时间复杂度：O(lgN)）
-   无序集合：一般用哈希表实现（增删查时间复杂度：O(1)）

### 应用：

-   去重


## 递归

-   函数自己调用自己
-   通过函数体进行循环过程

### 递归的三个关键：

1.  定义需要递归的问题（子问题）—— 数学归纳法思维
2.  确定递归边界 （否则会无限循环）
3.  保护和还原现场	（一般定义了全局变量需要考虑，如果通过函数传变量，一般不需要考虑）



### 需要注意的点：

1.  如果存在共享变量，而且递归过程会修改共享变量，则每次递归后，要还原现场，将共享变量改回原来的值
2.  存放结果的变量如果是共享变量，放入结果集之前，要 **copy** 一份，否则会被后续递归操作修改
3.  共享变量通常是：1、全局变量     2、类变量     3、指针类型（注意 Go 的 slice、map）



## 树

-   树的结构非常适合递归
-   关于树的问题，大都是通过递归来遍历树解决



## 分治法

把原问题分解为较小的同类子问题，分别解决后，再把结果合并起来

-   原问题和子问题都是同类重复的，可以通过不同参数，同一函数体解决
-   子问题结构能够向上合并

**分治划分子问题的标准：不重不漏**

**正确的划分方式：** 
例如生成括号，要保证左边不变，右边可变。即把一边定好，另一边可以改变。
也不能使用多分叉，那样会时间复杂度爆炸